#!/usr/bin/env bash

SCRIPT="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

SUITE=${SUITE:?"missing SUITE"}
SELENIUM_DOCKER_IMAGE=selenium/standalone-chrome:103.0
UAA_DOCKER_IMAGE=cloudfoundry/uaa:75.21.0
#UAA_DOCKER_IMAGE=cloudfoundry/uaa:76.0.0
KEYCLOAK_DOCKER_IMAGE=quay.io/keycloak/keycloak:18.0.0
HTTPD_DOCKER_IMAGE=httpd:latest
PADDING=""

tabs 4

print() {
  echo -e "${PADDING}$1"
}
begin() {
  print "\n$@"
  PADDING="${PADDING}\t"
}
end() {
  PADDING=`echo $PADDING | rev | cut -c 4- | rev`
  print "$@"
}
init_suite() {
  TEST_DIR=${SCRIPT}/../test
  TEST_CASES_DIR=${TEST_DIR}${TEST_CASES_PATH:?"missing TEST_CASES_PATH"}
  TEST_CONFIG_DIR=${TEST_DIR}${TEST_CONFIG_PATH:?"missing TEST_CONFIG_PATH"}
  DOCKER_NETWORK=${DOCKER_NETWORK:-rabbitmq_net}

  begin "Initializing suite ..."

  print "> TEST_CASES_DIR: ${TEST_CASES_DIR} "
  print "> TEST_CONFIG_DIR: ${TEST_CONFIG_DIR} "
  print "> DOCKER_NETWORK: ${DOCKER_NETWORK} "

  end "Initialized suite ..."
}

BIN=${SCRIPT}/../bin
LOGS=$PWD/logs/${SUITE}
SCREENS=$PWD/screens/${SUITE}


build_mocha_image() {
  if [[ "$(docker images -q mocha-test 2> /dev/null)" == "" ]]; then
    docker build -t mocha-test  --target test $SCRIPT/..
  fi
}

start_selenium() {
  begin "Starting selenium  ..."

  print "> SELENIUM_DOCKER_IMAGE: ${SELENIUM_DOCKER_IMAGE}"
  kill_container_if_exist selenium

  docker run \
    --detach \
    --name selenium \
    --net ${DOCKER_NETWORK} \
    -p 4444:4444 \
    --shm-size=2g \
    ${SELENIUM_DOCKER_IMAGE}

  wait_for_message selenium "Started Selenium Standalone"

  end "Selenium ready"
}

kill_container_if_exist() {
  docker stop $1 &> /dev/null || true && docker rm $1 &> /dev/null || true
}
wait_for_message() {
  attemps_left=10
  while ! docker logs $1 | grep -q "$2";
  do
      sleep 5
      print "Waiting 5sec for $1 to start ($attemps_left attempts left )..."
      ((attemps_left--))
      if [[ "$attemps_left" -lt 1 ]]; then
        print "Timed out waiting"
        exit 1
      fi
  done
}

init_rabbitmq() {
  RABBITMQ_CONFIG_DIR=${TEST_CONFIG_DIR}
  RABBITMQ_DOCKER_IMAGE=${RABBITMQ_DOCKER_IMAGE:-rabbitmq}
  RABBITMQ_URL=${RABBITMQ_URL:-http://rabbitmq:15672}
  RABBITMQ_CONFIG_FILENAME=${RABBITMQ_CONFIG_FILENAME:-rabbitmq.config}
  RABBITMQ_CONFIG_FILE=${RABBITMQ_CONFIG_DIR}/${RABBITMQ_CONFIG_FILENAME}

  print "> RABBITMQ_CONFIG_DIR: ${RABBITMQ_CONFIG_DIR}"
  print "> RABBITMQ_CONFIG_FILE: ${RABBITMQ_CONFIG_FILE}"
  print "> RABBITMQ_DOCKER_IMAGE: ${RABBITMQ_DOCKER_IMAGE}"
  print "> RABBITMQ_URL: ${RABBITMQ_URL}"
}

start_rabbitmq () {
  begin "Starting rabbitmq ..."

  init_rabbitmq
  kill_container_if_exist rabbitmq

  MOUNT_RABBITMQ_CONFIG="/etc/rabbitmq/rabbitmq.config"
  if [[ "$RABBITMQ_CONFIG_FILE" == *.conf ]]
  then
    MOUNT_RABBITMQ_CONFIG="/etc/rabbitmq/rabbitmq.conf"
  fi

  docker run \
    --detach \
    --name rabbitmq \
    --net ${DOCKER_NETWORK} \
    -p 15672:15672 -p 5672:5672 \
    -v ${RABBITMQ_CONFIG_DIR}/logging.conf:/etc/rabbitmq/conf.d/logging.conf:ro \
    -v ${RABBITMQ_CONFIG_FILE}:${MOUNT_RABBITMQ_CONFIG}:ro \
    -v ${RABBITMQ_CONFIG_DIR}/enabled_plugins:/etc/rabbitmq/enabled_plugins \
    -v ${RABBITMQ_CONFIG_DIR}:/config \
    ${RABBITMQ_DOCKER_IMAGE}

  wait_for_message rabbitmq "Server startup complete"

  end "RabbitMQ ready"
}
init_uaa() {
  UAA_CONFIG_PATH=${UAA_CONFIG_PATH:?"missing UAA_CONFIG_PATH"}
  UAA_CONFIG_DIR=${TEST_CONFIG_DIR}${UAA_CONFIG_PATH}
  UAA_BASE_URL=http://uaa:8080

  print "> UAA_CONFIG: ${UAA_CONFIG_DIR}"
  print "> UAA_BASE_URL: ${UAA_BASE_URL}"
  print "> UAA_DOCKER_IMAGE: ${UAA_DOCKER_IMAGE}"
}
start_uaa() {
  begin "Starting UAA ..."

  init_uaa
  kill_container_if_exist uaa

  docker run \
    --detach \
    --name uaa \
    --net ${DOCKER_NETWORK} \
    --publish 8080:8080 \
    --mount "type=bind,source=${UAA_CONFIG_DIR},target=/uaa" \
    --env UAA_CONFIG_PATH="/uaa" \
    --env JAVA_OPTS="-Djava.security.egd=file:/dev/./urandom" \
    ${UAA_DOCKER_IMAGE}

  wait_for_uaa
  end "UAA is ready"
}
wait_for_uaa() {
  wait_for_oidc_endpoint uaa $UAA_BASE_URL
}

init_keycloak() {
  KEYCLOAK_CONFIG_PATH=${KEYCLOAK_CONFIG_PATH:?"missing KEYCLOAK_CONFIG_PATH"}
  KEYCLOAK_CONFIG_DIR=${TEST_CONFIG_DIR}${KEYCLOAK_CONFIG_PATH}
  KEYCLOAK_BASE_URL=http://keycloak:8080/realms/test

  print "> KEYCLOAK_CONFIG: ${KEYCLOAK_CONFIG_DIR}"
  print "> KEYCLOAK_BASE_URL: ${KEYCLOAK_BASE_URL}"
  print "> KEYCLOAK_DOCKER_IMAGE: ${KEYCLOAK_DOCKER_IMAGE}"
}
start_keycloak() {
  begin "Starting keycloak ..."

  init_keycloak
  kill_container_if_exist keycloak

  # required in order to run in github actions
  chmod 777 ${KEYCLOAK_CONFIG_DIR}/h2
  chmod 666 ${KEYCLOAK_CONFIG_DIR}/h2/*

  docker run \
		--detach \
		--name keycloak \
    --net ${DOCKER_NETWORK} \
		--publish 8080:8080 \
		--env KEYCLOAK_ADMIN=admin \
		--env KEYCLOAK_ADMIN_PASSWORD=admin \
		--mount type=bind,source=${KEYCLOAK_CONFIG_DIR}/h2,target=/opt/keycloak/data/h2 \
		${KEYCLOAK_DOCKER_IMAGE} start-dev

  wait_for_keycloak
  end "Keycloak is ready"
}
wait_for_oidc_endpoint() {
  NAME=$1
  BASE_URL=$2

  max_retry=10
  counter=0
  print "Waiting for $NAME to start ... (BASE_URL: $BASE_URL)"
  until (docker run --net ${DOCKER_NETWORK} --rm curlimages/curl:7.85.0 -L --fail ${BASE_URL}/.well-known/openid-configuration >/dev/null 2>&1)
  do
    sleep 5
    [[ counter -eq $max_retry ]] && echo "Failed!" && exit 1
    print "Trying again. Try #$counter"
    ((counter++))
  done
  sleep 20

}
wait_for_keycloak() {
  wait_for_oidc_endpoint keycloak $KEYCLOAK_BASE_URL
}

init_fakeportal() {
  FAKE_PORTAL_URL=${FAKE_PORTAL_URL:-http://fakeportal:3000}
  FAKE_PORTAL_DIR=${SCRIPT}/../fakeportal
  CLIENT_ID="${CLIENT_ID:-rabbit_idp_user}"
  CLIENT_SECRET="${CLIENT_SECRET:-rabbit_idp_user}"

  print "> FAKE_PORTAL_URL: ${FAKE_PORTAL_URL}"
  print "> UAA_BASE_URL: ${UAA_BASE_URL}"
  print "> RABBITMQ_URL: ${RABBITMQ_URL}"
  print "> CLIENT_ID: ${CLIENT_ID}"
  print "> CLIENT_SECRET: ${CLIENT_SECRET}"
}
start_fakeportal() {
  begin "Starting fakeportal ..."

  init_fakeportal
  kill_container_if_exist fakeportal

  docker run \
    --detach \
    --name fakeportal \
    --net ${DOCKER_NETWORK} \
    --publish 3000:3000 \
    --env RABBITMQ_URL="${RABBITMQ_URL}" \
    --env UAA_URL="${UAA_BASE_URL}" \
    --env CLIENT_ID="${CLIENT_ID}" \
    --env CLIENT_SECRET="${CLIENT_SECRET}" \
    -v ${FAKE_PORTAL_DIR}:/code/fakeportal \
    mocha-test run fakeportal

  wait_for_url $FAKE_PORTAL_URL

  end "Fakeportal is ready"
}

init_fakeproxy() {
  FAKE_PROXY_URL=${FAKE_PROXY_URL:-http://fakeproxy:3000}
  FAKE_PROXY_DIR=${SCRIPT}/../fakeportal
  CLIENT_ID="${CLIENT_ID:-rabbit_idp_user}"
  CLIENT_SECRET="${CLIENT_SECRET:-rabbit_idp_user}"
  print "> FAKE_PROXY_URL: ${FAKE_PROXY_URL}"
  print "> UAA_BASE_URL: ${UAA_BASE_URL}"
  print "> RABBITMQ_URL: ${RABBITMQ_URL}"
  print "> CLIENT_ID: ${CLIENT_ID}"
  print "> CLIENT_SECRET: ${CLIENT_SECRET}"
}
start_fakeproxy() {
  begin "Starting fakeproxy ..."

  init_fakeproxy
  kill_container_if_exist fakeproxy

  docker run \
    --detach \
    --name fakeproxy \
    --net ${DOCKER_NETWORK} \
    --publish 3000:3000 \
    --env RABBITMQ_URL="${RABBITMQ_URL}" \
    --env UAA_URL="${UAA_BASE_URL}" \
    --env CLIENT_ID="${CLIENT_ID}" \
    --env CLIENT_SECRET="${CLIENT_SECRET}" \
    -v ${FAKE_PROXY_DIR}:/code/fakeportal \
    mocha-test run fakeproxy

  RABBITMQ_URL="$FAKE_PROXY_URL"

  wait_for_url $FAKE_PROXY_URL

  end "Fakeproxy is ready"

}

wait_for_url() {
  url=$1
  max_retry=10
  counter=0
  until (docker run --net rabbitmq_net --rm curlimages/curl:7.85.0 -L -f -v $url >/dev/null 2>&1)
  do
    print "Waiting for $url to start"
    sleep 5
    [[ counter -eq $max_retry ]] && echo "Failed!" && exit 1
    print "Trying again. Try #$counter"
    ((counter++))
  done
}

init_proxy() {
  HTTPD_CONFIG_DIR=${TEST_CONFIG_DIR}
  HTTPD_URL=http://proxy:8080

  print "> HTTPD_CONFIG: ${HTTPD_CONFIG_DIR}"
  print "> HTTPD_URL: ${HTTPD_URL}"
  print "> HTTPD_DOCKER_IMAGE: ${HTTPD_DOCKER_IMAGE}"
}
start_proxy() {
  begin "Starting proxy ..."

  init_proxy
  kill_container_if_exist proxy

  docker run \
    --detach \
    --name proxy \
    --net ${DOCKER_NETWORK} \
    --publish 8080:8080 \
    --mount "type=bind,source=${HTTPD_CONFIG_DIR},target=/usr/local/apache2/conf" \
    ${HTTPD_DOCKER_IMAGE}

  wait_for_url $HTTPD_URL

  end "Proxy is ready"
}


test () {
  kill_container_if_exist mocha
  begin "Running tests with env variables:"

  print "> RABBITMQ_URL: ${RABBITMQ_URL}"
  print "> UAA_URL: ${UAA_URL}"
  print "> FAKE_PORTAL_URL: ${FAKE_PORTAL_URL}"

  docker run \
    --rm \
    --name mocha \
    --net ${DOCKER_NETWORK} \
    --env RABBITMQ_URL=${RABBITMQ_URL} \
    --env UAA_URL=${UAA_URL} \
    --env FAKE_PORTAL_URL=${FAKE_PORTAL_URL} \
    --env RUN_LOCAL=false \
    -v ${TEST_DIR}:/code/test \
    -v ${SCREENS}:/screens \
    mocha-test test /code/test${TEST_CASES_PATH}

}

save_logs() {
  mkdir -p $LOGS
  save_container_logs selenium
}
save_container_logs() {
  docker container ls | grep $1 >/dev/null 2>&1 && docker logs $1 > $LOGS/$1.log || echo "$1 not running"
}

run() {
  init_suite

  build_mocha_image
  start_selenium

  trap _teardown EXIT

  [[ $(type -t _setup) == function ]] &&  _setup

  test
  TEST_RESULT=$?

  echo "Saving Logs to $LOGS ..."
  save_logs
  [[ $(type -t _save_logs) == function ]] &&  _save_logs

  echo "Tear down ..."
  [[ $(type -t _teardown) == function ]] &&  _teardown

  kill_container_if_exist selenium

  exit $TEST_RESULT

}
